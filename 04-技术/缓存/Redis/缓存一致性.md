---

UID: 20241113111136 
alias: 
tags: 
source: 
cssclass: 
obsidianUIMode: preview
obsidianEditingMode: source
created: 2024-11-13
---



![[Screenshot_20241113_083238.jpg]]



![[Screenshot_20241113_083546.jpg]]


查询数据时，写完数据库写缓存的时候，记得设置ttl，哪怕某次设置失败了，到期后会未命中，然后查库重建缓存，保证一致性
![[Screenshot_20241113_084026.jpg]]


增删改时，数据库和redis的顺序及操作
![[Screenshot_20241113_084250.jpg|并发情况下先操作缓存，后操作数据库]]
并发情况下，查询必更新要快得多，可能查到旧数据直接更新到缓存中之后，修改数据的线程才修改完，就造成了缓存不一致。

所以建议先操作数据库，再删除redis

![[缓存一致性-1.png|先操作数据库，再操作redis]]
先操作数据库，再删除redis，redis未命中后，都去查数据库，数据库里都是最新的值。

```ad-question
那么这种情况就不会有线程安全问题吗
```

也有概率

![[Screenshot_20241113_084712.jpg|概率比较小的并发安全问题]]
查询线程在读完数据库写缓存之前，更改线程更改数据库+删除缓存。这种情况也会造成缓存不一致，但是这种情况概率很小，③和④有写入操作，比较慢，要在设置读取数据设置缓存之间把这两件事儿都做完，不太现实。

即使出现了这种情况，缓存还有过期时间，最终也能同步。

为了进一步提高可靠性，还可以**[[延时双删]]** ，更新完数据库之后，删redis，过一段时间再删一次，确保redis数据没有被别的线程修改，即修改线程更新完数据库一定能删掉redis

![[Screenshot_20241113_085509.jpg]]
