---
author: yuanshuai
created: 2021-09-四 09:24:38
aliases: 
description:
tags: [设计模式]
---


# 代理模式
亦称：Proxy

**代理模式**是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。

![](Pasted%20image%2020210930092811.png)

## 问题
举个例子：有一个消耗大量系统资源的举行对象，只是偶尔需要使用，并非总是。
![](Pasted%20image%2020210930094133.png)
你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。

在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。

## 解决方案
代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。

![](Pasted%20image%2020210930094252.png)
```ad-note
代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。
```

这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。

## 结构
![](Pasted%20image%2020210930100821.png)

## 代码示例

```java

package com.yanshixiao.pattern.proxy;  
  
/**  
 * @author yuanshuai  
 */
public interface Sourceable {  
  
    /**  
	* 原方法  
	*/  
	void method();  
}

```

```java

package com.yanshixiao.pattern.proxy;  
  
/**  
 * @author yuanshuai  
 */
public class Source implements Sourceable{  
    /**  
 * 原方法  
 */  
	@Override  
	public void method() {  
		System.out.println("真实对象方法执行了");  
	}  
}

```

```java

package com.yanshixiao.pattern.proxy;  
  
/**  
 * @author yuanshuai  
 */
public class Proxy implements Sourceable{  
	private Sourceable source;  
 	
	public Proxy() {  
		super();  
		this.source = new Source();  
	}  
  
    public void before(){  
        System.out.println("额外的前置操作");  
 	}  
  
    public void after(){  
        System.out.println("额外的后续操作");  
 	}  
  
    /**  
	 * 原方法  
	 */  
	 @Override  
	 public void method() {  
		 before();  
		 source.method();  
		 after();  
	 }  
}

```

```java

package com.yanshixiao.pattern.proxy;  
  
/**  
 * @author yuanshuai  
 */public class ProxyMain {  
    public static void main(String[] args) {  
        Proxy proxy = new Proxy();  
 		proxy.method();  
 	}  
}

```

## 适用场景

- **延迟初始化** （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。

 	你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。
 
 - **访问控制** （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。

 	代理可仅在客户端凭据满足要求时将请求传递给服务对象。
 
  - **本地执行远程服务** （远程代理）。 适用于服务对象位于远程服务器上的情形。

 	在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。

 - **记录日志请求** （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。

 - **缓存请求结果** （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。

	代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。

 - **智能引用**。 可在没有客户端使用某个重量级对象时立即销毁该对象。

 	代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。

	代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。

## 优缺点
优点：
-   你可以在客户端毫无察觉的情况下控制服务对象。
-    如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。
-    即使服务对象还未准备好或不存在， 代理也可以正常工作。
-    开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。

缺点：
-  代码可能会变得复杂， 因为需要新建许多类。
-   服务响应可能会延迟。

## 与其他模式的关系
-   [适配器模式](适配器模式.md)能为被封装对象提供不同的接口， [代理模式](代理模式.md)能为对象提供相同的接口， [装饰模式](装饰模式.md)则能为对象提供加强的接口。
    
-   [外观模式](外观模式.md)与 [代理模式](代理模式.md)的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 _代理_与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与_外观_不同。
    
-   [装饰](装饰模式.md)和[代理](https://refactoringguru.cn/design-patterns/proxy)有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于_代理_通常自行管理其服务对象的生命周期， 而_装饰_的生成则总是由客户端进行控制。


