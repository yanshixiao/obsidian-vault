[toc]

redis数据都存在内存中，如果突然宕机，内存数据都会丢失，所以必须有持久化机制

Redis的持久化机制有2中

+ rdb快照
+ aof日志

rdb快照是内存全量数据的二进制序列化形式，在存储上非常紧凑，而aof是内存数据修改的指令记录文本。

### 快照原理
Redis是单线程程序（6.x之后是多线程）。这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。

在服务线上请求的同时，Redis还需要进行内存快照，内存快照要求 Redis 必须进行文件 IO 操作，可文件 IO 操作是不能使用多路复用 API。

这意味着单线程同时在服务线上的请求还要进行文件 IO 操作，文件 IO 操作会严重拖垮服务器请求的性能。还有个重要的问题是为了不阻塞线上的业务，就需要边持久化边响应客户端请求。持久化的同时，内存数据结构还在改变，比如一个大型的 hash 字典正在持久化，结果一个请求过来把它给删掉了，还没持久化完呢，这要怎么搞？

==使用操作系统的多进程COW（Copy On Write）机制来实现快照持久化==

### fork
Redis会调用glibc(linux的C函数库,即操作系统内核api)的fork产生一个子进程，在redis对外提供服务的同时进行持久化。

子进程刚产生时，它和父进程共享内存里的数据。子进程进行持久化，父进程仍然要处理客户端的请求，又不能改变子进程操作的内存，这时候就引入了操作系统的cow机制。

使用COW机制进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。

随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。

### AOF原理
aof存储的redis服务器的顺序指令序列，==只记录对内存进行修改操作的指令记录==

假设AOF存储了redis实例创建开始所有的修改操作指令，就可以通过对一个空的Redis实例重放AOF日志顺序执行所有记录的日志，来恢复Redis实例内存中的数据。

Redis接到指令后，先校验指令正确性，如果通过，就立刻把该指令文本存储到aof日志文件中，也就是先存储到磁盘，然后才执行，万一此时宕机，日志是完整的，只要重放一次就可以恢复到宕机前的状态。

> Redis 在长期运行的过程中，AOF 的日志会越变越长。如果实例宕机重启，重放整个AOF 日志会非常耗时，导致长时间 Redis 无法对外提供服务。所以需要对 AOF 日志瘦身。

### AOF重写
<font color="red">Redis提供了bgrewriteaof指令</font>用于对 AOF 日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。

> 个人理解：比如添加了一个key，又删除了，重写时就直接不写，最终的数据一致就行（反正都没有，+1 -1 = 0）

序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。

> AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘的。这就意味着如果机器突然宕机，AOF 日志内容可能还没有来得及完全刷到磁盘中，这个时候就会出现日志丢失。那该怎么办？

### fsync

还是glibc的一个函数**fsync(int fd)**, 可以将指定的文件强制从内存刷新到磁盘，这个操作是原子的。Redis只要实时调用它就可以保证即使宕机，也不会丢失aof内容，不过fsync是个IO操作，IO操作都很慢，不能这么搞

所以在生产环境的服务器中，Redis 通常是每隔 **1s** 左右执行一次 fsync 操作，周期 1s是可以配置的。这是在数据安全性和性能之间做了一个折中，在保持高性能的同时，尽可能使得数据少丢失。

### Redis4.0混合持久化

重启Redis时，很少使用rdb快照来恢复数据，那样会丢失很多数据，通常使用aof重放，但是重放aof比起rdb来说要慢的多，这样在Redis实例很大的情况下，启动需要花很长时间。

Redis4.0为了解决这个问题，有了新的持久化选项————**混合持久化**。<font color="blue">将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。</font>

于是在 Redis 重启的时候，可以**先加载 rdb 的内容，然后再重放增量 AOF 日志**就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。