### Base64



base64的编码都是按字符串长度，以每3个8bit的字符为一组，  

然后针对每组，首先获取每个字符的ASCII编码，  

然后将ASCII编码转换成8bit的二进制，得到一组3*8=24bit的字节，

然后再将这24bit划分为4个6bit的字节，并在每个6bit的字节前面都填两个高位0，得到4个8bit的字节，

然后将这4个8bit的字节转换成10进制，对照Base64编码表 （下表），得到对应编码后的字符。



需要注意的是

1. 要求被编码字符是8bit的，所以须在ASCII编码范围内，\u0000-\u00ff，中文就不行。
2. 如果被编码字符长度不是3的倍数的时候，则都用0代替，对应的输出字符为=

![image-20210826141159192](https://yanshixiao-markdown.oss-cn-beijing.aliyuncs.com/image-20210826141159192.png)

比如举下面2个例子：

a. 字符长度为能被3整除时：比如”Tom“：

```
T           o           m
ASCII:      84          111         109
8bit字节:   01010100    01101111    01101101
6bit字节:     010101      000110      111101      101101
十进制:     21          6           61          45
对应编码:   V           G           9           t
```

b. 字符串长度不能被3整除时，比如“Lucy”：

```
L           u           c           y
ASCII:      76          117         99          121
8bit字节:   01001100    01110101    01100011    01111001      00000000    00000000
6bit字节:     010011      000111      010101      100011      011110  010000  000000  000000
十进制:     19          7           21          35             30      16      (异常) (异常)      
对应编码:   T           H           V           j               e       Q       =       =
```

由于Lucy只有4个字母，所以按3个一组的话，第二组还有两个空位，所以需要用0来补齐。这里就需要注意，因为是需要补齐而出现的0，所以转化成十进制的时候就不能按常规用base64编码表来对应，所以不是a， 可以理解成为一种特殊的“异常”，编码应该对应“=”。




